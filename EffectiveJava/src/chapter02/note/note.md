# 第 2 章 创建和销毁对象

## 第 1 条 用静态工厂方法代替构造器

静态工厂方法与构造器不同的第一大优势在于，它们具有名称如果构造器没有确切地描述正被返回的对象，那么具有适当名称的静态工厂会更容易使用，代码也更易读。当一个类需要多个带有相同签名的构造器时，就用静态工厂代替构造器，并且仔细地选择名称以便突出静态工厂方法之间的区别。

静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象。这使得不可变类可以使用预先构建好的实例，或者将构建好的实例缓存起来，进行重复使用，从而避免创建不必要的重复对象。

静态工厂方法与构造器不同的第三大优势在于，它们可以返回原返回类型的任何子类型的对象，增加了灵活性。

静态工厂方法与构造器不同的第四大优势在于，所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。只要是已声明的返回类型的子类型，都是允许的。返回对象的类也可能随着发行版本的不同而不同。

EnumSet 没有公有的构造器，只有静态工厂方法。在 OpenJDK 实现中，它们返回两个子类之一的一个实例，具体取决于底层枚举类型的大小：如果它的元素有 64 个或者更少，静态工厂就会返回一个 RegalarEnumSet 实例，用单个
long 进行支持；如果枚举类型有 65 个或者更多元素，工厂就返回 JumboEnumSet 实例，用一个 long 数组进行支持。

静态工厂方法与构造器不同的第五大优势在于，方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在。这种灵活的静态工厂方法构成了服务提供者框架的基础，例如 JDBC
API。服务提供者框架是指这样一个系统：多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，并把它们从多个实现中解耦出来。

服务提供者框架中的组件：

- 服务接口，这是提供者实现的；

- 提供者注册 API，这是提供者用来注册实现的；

- 服务访问 API，这是客户端用来获取服务的实例。服务访问 API 是客户端用来指定某种选择实现的条件。如果没有这样的规定，API 就会返回默认实现的一个实例或者允许客户端遍历所有可用的实现。

- 服务提供者接口是可选的，它表示产生服务接口之实例的工厂对象。如果没有服务提供者接口，实现就通过反射的方式进行实例化。

对于 JDBC 来说，Connection 是其服务接口的一部分，DriverManager.registerDriver 是提供者注册 API，Driver.getConnection 是服务访问 API， Driver
是服务提供者接口。从 JDK 6 开始，Java 自带一个通用的服务提供者框架 java.util.ServiceLoader。JDBC 不用 ServiceLoader，因为前者出现得比后者早。

静态工厂方法的主要缺点在于，类如果不包含公有的或者受保护的构造器，就不能被子类化。

静态工厂方法的第二个缺点在于，程序员很难发现它们。在 API 文档中，它们没有像构造器那样在 API 文档中明确标识出来。

## 第 2 条 遇到多个构造器参数时要考虑使用构建器

静态工厂和构造器有个共同的局限性：它们都不能很好地扩展到大量的可选参数。

重叠构造器模式虽然可行，但是当有许多参数时，客户端代码很难编写和阅读。

JavaBeans 模式创建实例很容易，产生的代码读起来也很容易。但是因为构造过程被分到了几个调用中，在构造过程中 JavaBeans
可能处于不一致的状态。类无法仅仅通过校验构造器参数的有效性来保证一致性。试图使用处于不一致状态的对象将会导致失败，这种失败与包含错误的代码大相径庭，因此调试起来极为困难。与此相关的另一点不足在于，JavaBeans
模式使得把类做成不可变的可能性不复存在，这需要程序员付出额外的努力来确保它的线程安全。

Builder 模式既能保证像重叠构造器模式那样的安全性，也能保证像 JavaBeans 模式那样的可阅读性。它不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器或者静态工厂，得到一个 builder 对象。然后客户端在
builder 对象上调用类似于 setter 的方法来设置每个相关的可选参数。最后，客户端调用无参的 builder 方法来生成通常是不可变的对象。这个 builder 通常是它构建的类的静态成员类。

Builder 模式也适用于类层次结构。使用平行层次结构的 builder 时，各自嵌套在相应的类中。抽象类有抽象的 builder，具体类有具体的 builder。

Builder 模式十分灵活，可以利用单个 builder 构建多个对象。builder 的参数可以在调用 builder 方法来创建对象期间进行调整，也可以随着不同的对象而改变。builder
可以自动填充某些域，例如每次创建对象时自动增加序列号。

Builder 模式也确有不足。为了创建对象，必须先创建它的构建器，虽然创建这个构建器的开销在实践中不那么明显，但是在某些十分注重性能的情况下，可能就成问题了。Builder
模式还比重叠构造器模式更加冗长，因此它只有在有很多参数的时候才使用，比如 4 个或更多参数。

## 第 3 条 用私有构造器或枚举类型强化 Singleton 属性

私有构造器仅被调用一次，客户端的任何行为都不会改变这一点，但要提醒一点：享有特权的客户端可以借助 AccessibleObject.setAccessible
方法通过反射机制调用私有构造器。如果需要抵御这种攻击，可以修改构造器，让它在被要求创建第二个实例时抛出异常。

公有域方法的主要优势在于，API 很清楚地表明了这个类是一个单例：公有的静态域是 final 的，所以该域总是包含相同的对象引用。第二个优势在于它更简单。

静态工厂方法的优势：

- 它提供了灵活性：在不改变 API 的前提下，可以改变该类是否应该为单例的想法。工厂方法返回该类的唯一实例，但是，它很容易被修改，比如改成每个调用该方法的线程返回一个唯一的实例；

- 如果应用程序需要，可以编写一个泛型单例工厂；

- 可以通过方法引用作为提供者，比如 Elvis::instance 就是一个Supplier<Elvis>。

除非满足以上任意一种优势，否则还是优先考虑公有域的方法。

为了保证单例类是可序列化的，不只需要加上 implements Serializable，还要保证所有实例域都是 transient 的，并提供一个 readResolve 方法。否则，每次反序列化一个序列化的实例时，就会创建一个新的实例。

枚举类也能实现单例，这种方法在功能上与公有域方法相似，但更简洁，无偿地提供了序列化机制，绝对防止多次实例化，即使实在面对复杂的序列化或反射攻击时。注意，如果单例必须扩展一个超类，而不是扩展枚举时，则不宜使用该方法（虽然可以声明枚举去实现接口）。

## 第 4 条 通过私有构造器强化不可实例化的能力

工具类不希望被实例化，因为实例化对它没有任何意义。然而，在缺少显式构造器的情况下，编译器会自动提供一个公有的、无参的缺省构造器。企图通过将类做成抽象类来强制该类不可被实例化是行不通的，该类可以被子类化，并且该子类也可以被实例化。这样做甚至会误导用户，以为这种类是专门为了继承而设计的。实际上，只要让这个类包含一个私有构造器，它就不能被实例化。这种习惯用法也会有副作用，它使得一个类不能被子类化。所有的构造器都必须显式或隐式调用超类构造器，在这种情况下，子类就没有可访问的超类构造器可调用了。

## 第 5 条 优先考虑依赖注入来引用资源

不要用单例或静态工具类来实现依赖一个或多个底层资源的类，且该资源的行为还会影响到该类的行为，也不要直接用这个类来创建这些资源，而应该将这些资源或者工厂传给构造器或者静态工厂或者构建器，通过它们来创建类。这个实践被称为依赖注入，它极大地提升了类的灵活性、可重用性和可测试性。

## 第 6 条 避免创建不必要的对象

对于同时提供了静态工厂方法和构造器的不可变类，通常优先使用静态工厂方法，以避免创建不必要的对象。例如，静态工厂方法 Boolean.valueOf(String) 几乎总是优先于构造器 Boolean(String)，构造器
Boolean(String) 在 Java 9 中已经被废弃。

要优先使用基本类型而不是装箱类型，要当心无意识的自动装箱。

## 第 7 条 消除过期的对象引用

如果一个栈先增长，后收缩，那么从栈中弹出来的对象将不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，它们也不会被回收。这是因为栈内部维护者对这些对象的过期引用。所谓的过期引用，是指永远也不会再被解除的引用。对于本例的 Stack
类，凡是在 elements 数组的“活动部分”之外的任何引用都是过期的。活动部分是指 elements 数组中下标小于 size
的那部分。这类的问题的修复方法很简单：一旦对象引用已经过期，只需清空这些引用即可。清空引用的另一个好处是，如果它们以后又被错误地解除引用，程序会立即抛出 NPE 异常，而不是悄悄地错误运行下去。

一般来说，只要类是自己管理内存的，程序员就应该警惕内存泄漏问题。一旦元素被释放掉，则该元素中包含的任何对象引用都应该被清空。

除了无意识的对象保持外，内存泄漏的另一个常见来源是缓存。一旦把对象引用放到缓存中，它就很容易被遗忘掉，从而使得它不再有用之后很长一段时间内仍然保留在缓存中。如果缓存中的项过期后需要自动删除，可以使用 WeakHashMap。

内存泄漏的第三个常见来源是监听器和其他回调。如果实现了一个 API，客户端在这个 API
中注册回调，却没有显式取消注册，那么除非采取那些动作，否则它们会不断堆积起来。确保回调立即被当作垃圾回收的最佳方法是只保存它们的弱引用，例如，只将它们保存成 WeakHashMap 中的键。

## 第 8 条 避免使用终结方法和清除方法

finalizer 通常是不可预测的，也是很危险的，一般情况下是不必要的。使用 finalizer 会导致行为不稳定，性能降低，以及可移植性问题。在 Java 9 中用 cleaner 代替了 finalizer。cleaner 没有
finalizer 那么危险，但仍然是不可预测、运行缓慢的，一般情况下也是不必要的。

finalizer 和 cleaner 的缺点在于不能保证会被及时执行。从一个对象变得不可达开始，到它的 finalizer 被执行，所花费的这段时间是任意长的。这意味着，注重时间的任务不应该由 finalizer 或 cleaner
来完成。

及时地执行 finalizer 和 cleaner 正是垃圾回收算法的一个主要功能，这种算法在不同的 JVM 实现中大相径庭。如果程序依赖于 finalizer 和 cleaner 被执行的时间点，那么这个程序的行为在不同 JVM
中的运行表现可能会截然不同。

延迟终结过程并不只是个理论问题，在很少见的情况下，为类提供终结方法，可能随意地延迟其实例的回收过程。在这方面， cleaner 比 finalizer 稍好一些，因为类的设计者可以控制自己的清除线程，但 cleaner
仍然会在后台运行，处于垃圾回收器的控制下，因此不能确保及时清除。

Java 语言规范不仅不保证 finalizer 或 cleaner 会被及时执行，而且根本不保证它们会被执行。当一个程序终止时，某些已经无法访问的对象上的 finalizer 却根本没有被执行是完全有可能的。永远不应该依赖
finalizer 或 cleaner 来更新重要的持久状态。

不要被 System.gc 和 System.runFinalization 这两个方法诱惑，它们确实增加了 finalizer 和 cleaner 被执行的机会，但不保证 finalizer 或 cleaner
一定会被执行。唯一声称保证它们会被执行的两个方法是 System.runFinalizersOnExit 和 Runtime.runFinalizersOnExit，这两个方法都有致命缺陷，并且已经废弃很久。

使用 finalizer
的另一个问题是：如果忽略在终结过程中被抛出来的未捕获异常，该对象的终结过程也会终止。未被捕获的异常会使对象处于破坏状态，如果另一个线程企图使用这种被破坏的对象，则可能发生任何不确定的行为。正常情况下，未被捕获的异常将会使线程终止，并打印出堆栈。但是，如果异常发生在
finalizer 中，则不会如此，甚至连警告也不会打印出来。cleaner 没有这个问题，因为使用 cleaner 的一个类库在控制它的线程。

finalizer 有一个严重的安全问题：它们为终结方法攻击打开了类的大门。终结方法攻击背后的思想很简单：如果从构造器或者它的序列化对等体抛出异常，恶意子类的 finalizer 就可以在构造了一部分的应该已经半途夭折的对象上运行。这个
finalizer 会将该对象的引用记录在一个静态域中，阻止它被垃圾回收。一旦记录到异常的对象，就可以轻松在这个对象上调用任何原本永远不允许在这里出现的方法。从构造器抛出的异常，应该足以防止对象继续存在，有了
finalizer，这一点就做不到了。这种攻击可能造成致命后果。final 类不会受到终结方法攻击，因为没人能编写出 final 类的恶意子类。为了防止非 final 类受到终结方法攻击，要编写一个空的 final 的 finalize
方法。

finalizer 和 cleaner 的好处：

- 当资源的所有者忘记调用它的 close 方法时，finalizer 或 cleaner 可以充当“安全网”。虽然这样做并不能保证 finalizer 或
  cleaner会被及时执行，但是在客户端无法结束操作时，迟一点释放资源总比永远不释放要好。

- 本地对等体是一个本地对象，普通对象通过本地方法委托给一个本地对象。因为本地对等体不是一个普通对象，所以垃圾回收器不会知道它，当它的 Java 对等体被回收时，它不会被回收。如果本地对等体没有关键资源，并且性能也可接受的话，那么
  finalizer 或 cleaner 正是执行这项任务最合适的工具。如果本地对等体拥有必须被及时终止的资源，或者性能无法接受，那么该类就应该具有一个 close 方法。

## 第 9 条 try-with-resources 优先于 try-finally

在处理必须关闭的资源时，始终优先考虑用 try-with-resources，而不是 try-finally。这样的得到的代码将更加简洁、清晰，产生的异常也更有价值。





